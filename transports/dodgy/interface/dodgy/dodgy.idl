/*
 *   Copyright (c) 2026 Edward Boggis-Rolfe
 *   All rights reserved.
 */

#import "rpc/rpc_types.idl"

namespace rpc
{
    namespace dodgy
    {
        enum message_direction
        {
            send = 1,
            receive = 2,
            one_way = 3
        };

        struct envelope_prefix
        {
            uint64_t version;
            message_direction direction;
            uint64_t sequence_number;
            uint64_t payload_size;
        };

        struct envelope_payload
        {
            uint64_t payload_fingerprint;
            std::vector<uint8_t> payload;
        };

        // When connecting two zones together we need to establish two channel connections one for the
        // client to send requests and one for the server.
        // When it is a peer to peer connection then the client is the initiator of the connection and server is the
        // responder to that connection request otherwise they are technically the same.
        // Once the channels are established the peers initiate rpc calls from their respective channels.
        // Responses are sent back on the same channel that the request was sent on.

        // A client may choose to not send an object for the server to add_ref to however the server will have to send
        // an object for the client to add_ref to otherwise the channels will auto clean up as there is no positive
        // reference count in either diretion.

        // Note the zone ids for the same zones may be different between the caller and the destination, therefore a mapping
        // is required to map the zone id that the caller uses to the zone id that the destination uses.
        // so long as the two servers are the only agents to generate zone ids then the mapping will be consistent.
        // however if there is a mesh type arrangement then a global mapping service is required.

        struct init_client_channel_send
        {
            // the zone id of the caller derived from the caller
            uint64_t caller_zone_id;
            // the object id of the callback object from the caller
            uint64_t caller_object_id;
            // the zone id of the destination derived from the caller
            uint64_t destination_zone_id;
        };

        struct init_client_channel_response
        {
            int err_code;
            // the destination zone id derived from the destination
            uint64_t destination_zone_id;
            // the destination callable object id generated from the destination
            uint64_t destination_object_id;
            // the zone id of the caller derived from the destination
            uint64_t caller_zone_id;
        };

        struct call_send
        {
            rpc::encoding encoding;
            uint64_t tag;
            uint64_t caller_zone_id;
            uint64_t destination_zone_id;
            uint64_t object_id;
            uint64_t interface_id;
            uint64_t method_id;
            std::vector<char> payload;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct call_receive
        {
            std::vector<char> payload;
            std::vector<rpc::back_channel_entry> back_channel;
            int err_code;
        };

        struct post_send
        {
            rpc::encoding encoding;
            uint64_t tag;
            uint64_t caller_zone_id;
            uint64_t destination_zone_id;
            uint64_t object_id;
            uint64_t interface_id;
            uint64_t method_id;
            std::vector<char> payload;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct try_cast_send
        {
            uint64_t caller_zone_id;
            uint64_t destination_zone_id;
            uint64_t object_id;
            uint64_t interface_id;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct try_cast_receive
        {
            std::vector<rpc::back_channel_entry> back_channel;
            int err_code;
        };

        struct addref_send
        {
            uint64_t destination_zone_id;
            uint64_t object_id;
            uint64_t caller_zone_id;
            uint64_t known_direction_zone_id;
            rpc::add_ref_options build_out_param_channel;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct addref_receive
        {
            std::vector<rpc::back_channel_entry> back_channel;
            int err_code;
        };

        struct release_send
        {
            uint64_t destination_zone_id;
            uint64_t object_id;
            uint64_t  caller_zone_id;
            rpc::release_options options;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct release_receive
        {
            std::vector<rpc::back_channel_entry> back_channel;
            int err_code;
        };

        struct object_released_send
        {
            rpc::encoding encoding;
            uint64_t destination_zone_id;
            uint64_t object_id;
            uint64_t caller_zone_id;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct transport_down_send
        {
            rpc::encoding encoding;
            uint64_t destination_zone_id;
            uint64_t caller_zone_id;
            std::vector<rpc::back_channel_entry> back_channel;
        };

        struct close_connection_send
        {};
        struct close_connection_received
        {};

        // NEW: Message to trigger a simulated network failure
        // This causes the transport to immediately send transport_down to both sides
        struct network_failure_send
        {
            // Which side initiates the failure (0 = both, 1 = send side, 2 = receive side)
            uint64_t failure_side;
        };
    }
}
